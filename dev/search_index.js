var documenterSearchIndex = {"docs":
[{"location":"advanced/#Internals-and-advanced-usage","page":"Internals","title":"Internals and advanced usage","text":"","category":"section"},{"location":"advanced/","page":"Internals","title":"Internals","text":"The main design goal is to make By robust and easy to use. However, this package also tries to achieve good performance, and that often means inferring the key- and value-types of the returned Dict. In detail, here is what actually happens for a ficticious operation aggregator (e.g., like count, sum, or push!) and \"by\" function f:","category":"page"},{"location":"advanced/","page":"Internals","title":"Internals","text":"If you call aggregator(By{K,V}(f), itr), it should return a Dict{K,V}. It does not rely on inference.\nIf you call aggregator(By(f), itr), it will determine whether itr has a known eltype (see Base.IteratorEltype):\nif the eltype T is known, it infers K from f(::T) and V from aggregator and T\nif the eltype is unknown, it will aggregate to Dict{Any,Any} internally, and then try to \"tighten\" the eltype upon return.","category":"page"},{"location":"advanced/","page":"Internals","title":"Internals","text":"You can use ByOperations.UNKNOWN if you want to tighten selectively, e.g., By{UNKNOWN,Any} will tighten the keytype but not the valtype, and so on.","category":"page"},{"location":"advanced/","page":"Internals","title":"Internals","text":"To illustrate these considerations, let's experiment with both By(f) and By{K,V}(f) in three different cases:","category":"page"},{"location":"advanced/","page":"Internals","title":"Internals","text":"where the eltype is known and concrete (e.g., Vector{Int})\nwhere the eltype is known and abstract (e.g., Vector{Any})\nwhere the eltype is unknown","category":"page"},{"location":"advanced/","page":"Internals","title":"Internals","text":"For the third case, it will help if we define a custom container type:","category":"page"},{"location":"advanced/","page":"Internals","title":"Internals","text":"struct UnknownEltype\n    container\nend\n\nBase.IteratorEltype(::Type{UnknownEltype}) = Base.EltypeUnknown()\n\nBase.iterate(u::UnknownEltype) = iterate(u.container)\nBase.iterate(u::UnknownEltype, s) = iterate(u.container, s)","category":"page"},{"location":"advanced/","page":"Internals","title":"Internals","text":"Now, let's set up the data we need for benchmarking:","category":"page"},{"location":"advanced/","page":"Internals","title":"Internals","text":"julia> by1 = By{Bool,Int}(isodd)\nBy{Bool, Int64, typeof(isodd)}(isodd)\n\njulia> by2 = By(isodd)\nBy{ByOperations.UNKNOWN, ByOperations.UNKNOWN, typeof(isodd)}(isodd)\n\njulia> vconcrete = collect(1:11);    # Vector{Int}\n\njulia> vabstract = Any[(1:11)...];   # Vector{Any}\n\njulia> vunknown = UnknownEltype(vconcrete);    # unknown eltype","category":"page"},{"location":"advanced/","page":"Internals","title":"Internals","text":"On the author's machine,","category":"page"},{"location":"advanced/","page":"Internals","title":"Internals","text":"julia> using BenchmarkTools\n\njulia> @btime sum($by, $v);   # supply either by1 or by2, and either vconcrete, vabstract, or vunknown","category":"page"},{"location":"advanced/","page":"Internals","title":"Internals","text":"yields the following results:","category":"page"},{"location":"advanced/","page":"Internals","title":"Internals","text":"Container By{K,V}(f) By(f)\nvconcrete 150.153 ns (4 allocations: 432 bytes) 150.652 ns (4 allocations: 432 bytes)\nvabstract 343.598 ns (4 allocations: 432 bytes) 906.775 ns (4 allocations: 512 bytes)\nvunknown 861.281 ns (26 allocations: 960 bytes) 1.327 μs (30 allocations: 1.44 KiB)","category":"page"},{"location":"advanced/","page":"Internals","title":"Internals","text":"In the vunknown row, much of the cost in the By{K,V}(f) case is the unknown type of vunknown.container; the alternative definition","category":"page"},{"location":"advanced/","page":"Internals","title":"Internals","text":"struct UnknownEltype2\n    container::Vector{Int}\nend\nBase.IteratorEltype(::Type{UnknownEltype}) = Base.EltypeUnknown()","category":"page"},{"location":"advanced/","page":"Internals","title":"Internals","text":"yields substantially better performance (302.490 ns (4 allocations: 432 bytes)). The By(f) case improves less dramatically (1.039 μs (8 allocations: 944 bytes)).","category":"page"},{"location":"reference/#ByOperations","page":"Reference","title":"ByOperations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Documentation for ByOperations.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ByOperations]","category":"page"},{"location":"reference/#ByOperations.By-Tuple","page":"Reference","title":"ByOperations.By","text":"By(f=identity)\nBy{K,V}(f=identity)\n\nBy creates an object that triggers \"key-selective\" operations on a collection. f is the function that generates the key, and the operation determines the resulting value. The return value is typically a Dict. Optionally, you can specify the key K and value V types of that Dict, which can help performance in certain cases (see the documentation for details).\n\nExamples\n\njulia> count(By(lowercase), \"Hello\")\nDict{Char, Int64} with 4 entries:\n  'h' => 1\n  'l' => 2\n  'e' => 1\n  'o' => 1\n\njulia> push!(By(isodd), 1:11)\nDict{Bool, Vector{Int64}} with 2 entries:\n  0 => [2, 4, 6, 8, 10]\n  1 => [1, 3, 5, 7, 9, 11]\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ByOperations\nDocTestSetup = quote\n    using ByOperations\nend","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is not yet registered, so you'll have to enter package mode with ] and then:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.10) pkg> dev https://github.com/timholy/ByOperations.jl","category":"page"},{"location":"#Tutorial","page":"Home","title":"Tutorial","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All examples assume that you've executed using ByOperations in the current session.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To count all the letters in a string:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> count(By(), \"Hello\")\nDict{Char, Int64} with 4 entries:\n  'H' => 1\n  'l' => 2\n  'e' => 1\n  'o' => 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you also want to ignore case, then use","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> count(By(lowercase), \"HelLo\")\nDict{Char, Int64} with 4 entries:\n  'h' => 1\n  'l' => 2\n  'e' => 1\n  'o' => 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"and all characters will be converted to lowercase before counting them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or, combine multiple sum(f, itr) statements into a single command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> sum(By(isodd), 1:11)\nDict{Bool, Int64} with 2 entries:\n  0 => 30\n  1 => 36","category":"page"},{"location":"","page":"Home","title":"Home","text":"or collect such items for further analysis:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> push!(By(isodd), 1:11)\nDict{Bool, Vector{Int64}} with 2 entries:\n  0 => [2, 4, 6, 8, 10]\n  1 => [1, 3, 5, 7, 9, 11]","category":"page"}]
}
